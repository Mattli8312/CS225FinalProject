# Project Results

Overall, we managed to accomplish the main parts of our proposed goals, specifically implementing breadth-first search, Dijkstra, and A Star's pathfinding algorithm on an adjacency matrix. We learned many new things during this process including how to build a makefile, parsing data using stringstream and getline, and designing and running testcases. The biggest obstacle we faced during the development of this program was getting the makefile to work alongside parsing the data and retrieving the right pieces of data such as the IATA and the longitude and latitude coordinates. 

One of the key discoveries we made when designing this program was when we were implementing the Dijkstra pathfinding algorithm. Initially, when we designed this algorithm, we used a lazy approach which was to check all of the nodes and compare the distance travelled to that node and "relax" the node if necessary ("relax" means we compare the current distance travelled from the beginning to that node and we compare it to that node's current minimum distance). While this approch certainly works, it does run into issues when dealing with massive graphs, such as the current flightpath graph which contains over 6000 airports and over 60000 edges. Hence, to optimize our design, we utilized a priority queue containing a queue of Nodes. We used a struct to define this Node, which contains three parameters: n1, the source node, n2, the destination node, and w which is the minimum edge weight. To implement a minimum heap priority queue, we used an operator in our Dijkstra class to compare the weights of both nodes. By using this minimum heap, we could prioritize edges with the least cost and avoid edges with the widest costs instead of checking every cost and relaxing those weights and paths. 
Another thing we learned when designing this program was when we implemented the AStar pathfinding algorithm, which we also used a priority queue for. Initially, our plan was to use the exact distance from the current node we are analyzing to the final node in the graph, but this implementation would be costly in terms of time. Hence, we learned about various heuristics in calculating the h cost including the Euclidean and Manhattan distance. 

What we were not able to accomplish that was specified in the proposed goals however, was having the traversals and pathfinding algorithms run in O(n) time, (which we realized was partically impossible for an adjacency matrix). Another thing we were unable to accomplish was for airports that didn't have specific IATA codes, we would assign them random IATA codes and random edges (Also impractical). 
